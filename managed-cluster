#!/usr/bin/env -S bash --norc --noprofile -i

${DEBUG:-false} && set -x

if [ -d /opt/homebrew/Cellar/coreutils/9.0/libexec/gnubin ]; then
    export PATH="/opt/homebrew/Cellar/coreutils/9.0/libexec/gnubin:$PATH"
fi

export ROOT_DIR=$(readlink -ne $(dirname $0))
source $ROOT_DIR/root/etc/profile.d/getup.sh
export PATH="$PATH:$ROOT_DIR/root/usr/local/bin/"

if [ -t 0 ]; then
    COLOR_RED="$(tput setaf 1)"
    COLOR_GREEN="$(tput setaf 2)"
    COLOR_YELLOW="$(tput setaf 3)"
    COLOR_BOLD="$(tput bold)"
    COLOR_RESET="$(tput sgr0)"
fi

function copy_from_template()
{
    if [ $# -lt 2 ]; then
      warn "Invalid or missing parameters: $0 [src-dir] [dest-dir] [rsync-params]"
      return 1
    fi

    local src=$1
    local dest=$2
    shift 2
    local rsync_params="$@"

    if ! [ -d "$src" ]; then
      warn "Source dir not found: $src"
      return 1
    fi

    if ! [ -d "$dest" ]; then
      mkdir -p "$dest"
    fi

    rsync -va $rsync_params $src/ ${common_template_files[@]} "$dest"
}

function sync_from_template()
{
    local dest=$cluster_dir

    if ! [ -d "$dest" ]; then
      warn "Cluster dir not found: $dest"
      return 1
    fi

    if ! [ -e "$ROOT_DIR/repo.conf" ]; then
      warn "Missing $ROOT_DIR/repo.conf"
      return 1
    fi

    if ! [ -e "$dest/cluster.conf" ]; then
      warn "Missing $dest/cluster.conf"
      return 1
    fi

    source_env $ROOT_DIR/repo.conf || return 1
    source_env $dest/cluster.conf || return 1

    if [ -z "$customer" ] || [ -z "$name" ] || [ -z "$type" ]; then
      warn "Invalid $dest/cluster.conf: customer=${customer} name=${name} type=${type}"
      return 1
    fi

    local src=templates/$type

    if ! [ -d "$src" ]; then
      warn "Template dir not found: $src"
      return 1
    fi

    if ! $force; then
        if ! ask "Copy from $src to $dest? [Y/n]"; then
            return 0
        fi
    fi

    copy_from_template $src $dest --exclude=manifests/cluster/ --exclude=manifests/base/kustomization.yaml --exclude=\*.swp
}

#function require_config()
#{
#    local _name="${1}"
#    local _description="${2}"
#    local _filename="${3}"
#
#    # use value if already exists
#    if [ -n "${!_name}" ]; then
#        set_config ${_name}="${!_name}" "$_description" $_filename
#        return 0
#    fi
#
#    until read_config "$_name" "$_description"; do
#        warn "Value can't be empty"
#    done
#
#    local _value="${!_name}"
#    set_config "$_name='$_value'" "$_description" $_filename
#}

function list_cluster_types()
{
    local types=( templates/*/ )
    types=( ${types[@]#*/} )
    types=( ${types[@]%/} )
    types=( "${types[@]/manifests}" ) ## remove manifests from types
    echo ${types[*]}
}

function select_cluster_type()
{
    # use value if already exists
    if [ -n "$opt_type" ]; then
        for i in $(list_cluster_types); do
            if [ "$opt_type" == "$i" ]; then
                export type="$opt_type"
                return
            fi
        done
        warn Invalid cluster type: $opt_type
        return 1
    fi

    local types=$(list_cluster_types)
    local PS3=$(prompt "Select cluster type")

    select type in ${types}; do
        break;
    done

    export type
}

function generate_ssh_key()
{
    if ! [ -e $cluster_dir/identity ]; then
        info Generating $cluster_dir/identity
        ssh-keygen -t $ssh_key_type -b $ssh_key_length -f $cluster_dir/identity -N "" -C "$customer/$name/$type"
        ssh-keygen -yf $cluster_dir/identity > $cluster_dir/identity.pub
    else
        info Using existing $cluster_dir/identity
    fi

    info Generating $cluster_dir/known_hosts
    ssh-keyscan github.com > $cluster_dir/known_hosts
}

function select_cluster()
{
    local cluster_dir=""

    if [ $# -eq 0 ]; then
        local clusters=( clusters/*/*/ )
    else
        clusters=( $@ )
    fi

    clusters=( ${clusters[*]%/} )

    export CLUSTER_CONFIG

    if [ ${#clusters[*]} -eq 1 ]; then
        CLUSTER_CONFIG=$clusters/cluster.conf
        if ! has_valid_config $CLUSTER_CONFIG; then
            warn Config not found: $CLUSTER_CONFIG
            return 1
        fi

        echo -n ${clusters}
        return
    fi

    cluster_names=( ${clusters[*]#*/} )
    cluster_names=( ${cluster_names[*]%/*} )
    cluster_types=( ${clusters[*]##*/} )

    if type dialog &>/dev/null; then
        exec 3>.tmp
        eval dialog --output-fd 3 --menu "'Select cluster'" 0 0 0 \
            "$(for i in $(seq 0 $(( ${#clusters[*]} - 1 )) ); do echo -n " $i '[${cluster_types[$i]}] ${cluster_names[$i]}'"; done)" \
            '---' '---' \
            b "'Bootstrap cluster'"  >&2
            #s 'Sync from template' >&2
        idx=$(<.tmp)
        rm -f .tmp
        case "$idx" in
            [0-9]*)
                cluster_dir=${clusters[$idx]}
            ;;
            *) cluster_dir=$idx
        esac
    else
        local PS3="${COLOR_GREEN}${COLOR_BOLD}Select cluster to start: ${COLOR_RESET} "

        select cluster_dir in ${clusters[*]}; do
            CLUSTER_CONFIG=$cluster_dir/cluster.conf
            if has_valid_config $cluster_dir; then
                break
            else
                warn Config not found: $CLUSTER_CONFIG
            fi
        done
    fi

    echo $cluster_dir
}

function assert_cluster_dir()
{
    if ! [ -e "$cluster_dir/cluster.conf" ]; then
        warn "Invalid cluster dir: $cluster_dir"
        exit 1
    fi
}

function update_git_remotes()
{
    line
    info Updating remotes

    if [ -z "$upstream" ]; then
        warn Missing UPSTREAM remote
        return 1
    fi

    if [ -z "$origin" ]; then
        warn Missing ORIGIN remote
        return 1
    fi

    git remote remove upstream 2>/dev/null || true
    git remote add upstream "$upstream"
    git remote set-url --push upstream FORBIDEN

    git remote remove origin 2>/dev/null || true
    git remote add origin $origin
}

function start_container()
{
    assert_cluster_dir

    if $run_as_root; then
        : ${CONTAINER_USER_ID:=0}
        : ${CONTAINER_GROUP_ID:=0}
    else
        : ${CONTAINER_USER_ID:=$(id -u)}
        : ${CONTAINER_GROUP_ID:=$(id -g)}
    fi

    local docker_run_options_defaults=(
        --cap-add=SYS_PTRACE
        --network host
        --rm
        -it
        --env-file $ROOT_DIR/.dockerenv
        -v $(readlink -ne $cluster_dir):/cluster
        -v $ROOT_DIR:/repo
        -v $HOME:/home/_host:ro
    )

    if [ -e /var/run/docker.sock ]; then
        docker_run_options_defaults+=(
            -v /var/run/docker.sock:/var/run/docker.sock
        )
    fi

    {
        echo CONTAINER_USER_ID=$CONTAINER_USER_ID
        echo CONTAINER_GROUP_ID=$CONTAINER_GROUP_ID
        echo GH_TOKEN=$GH_TOKEN
        echo debug=$debug
        echo verbose=$verbose
    } > .dockerenv

    if $force_docker_image_build; then
        make
    else
        if docker inspect ${docker_image} &>/dev/null; then
            if [ Dockerfile.centos8 -nt Dockerfile.centos8.base ]; then
                local dockerfile_modified_ts=$(stat --format %Y Dockerfile.centos8)
            else
                local dockerfile_modified_ts=$(stat --format %Y Dockerfile.centos8.base)
            fi
            local image_created=$(docker inspect ${docker_image} -f '{{.Created}}')
            local image_created_ts=$(date --date="$image_created" +%s)

            if (( dockerfile_modified_ts > image_created_ts )); then
                if ask "Docker image ${docker_image} is outdated. Build now? [Y/n]"; then
                    make
                fi
            fi
        fi
    fi

    info Starting cluster: $cluster_dir with docker image ${docker_image}
    docker_run="docker run ${docker_run_options_defaults[@]} ${docker_image} ${docker_command}"
    info \$ $docker_run
    #echo
    eval $sudo $docker_run
}

###########
## Start ##
###########

function usage()
{
    echo "Usage: $0 COMMAND [OPTIONS...] "
    echo
    echo "Creates and manage CLUSTER-DIR (./clusters/\$name/\$type/) from outside manager container."
    if [ -z "$command" ]; then
        echo
        echo "Available commands and options:"
        echo
        echo "    -d, --debug      Turn bash debug messages on (set -x). Implies --verbose."
        echo "    -h, --help       This help message."
        echo "    -v, --verbose    Turn verbose messages on."
    else
        echo
        echo "Run \`$0 --help\` for full help."
    fi

    if [ -z "$command" ] || [ "$command" == "create" ]; then
        echo "$COLOR_GREEN"
        echo "  -> create                     Creates a new cluster from ./templates/\$type into CLUSTER-DIR (./clusters/\$name/\$type/)." "$COLOR_RESET"
        echo "     -c, --customer NAME        Customer name."
        echo "         --force                Force create even if CLUSTER-DIR exists."
        echo "     -f, --flux-git-repo URL    Define flux git repository address. Defaults to ORIGIN. (format: ssh://user@host/path/to/repo)."
        echo "     -k, --ssh-key-type         SSH key type (default: $ssh_key_type)."
        echo "     -l, --ssh-key-length       SSH key length, depends on ssh key type."
        echo "     -n, --name NAME            Unique name for new cluster."
        echo "     -o, --origin REMOTE        Define ORIGIN remote address."
        echo "     -t, --type NAME            Cluster type: $(list_cluster_types)."
        echo "     -u, --upstream REMOTE      Define UPSTREAM remote address (default: $default_upstream)."
    fi

    if [ -z "$command" ] || [ "$command" == "start" ]; then
        echo "$COLOR_GREEN"
        echo "  -> start [CLUSTER-DIR] [-- params...]    Start container for a cluster, passing optional \`docker run -- params\`." "$COLOR_RESET"
        echo "         --force-docker-image-build        Force building local docker image."
        echo "     -i, --image NAME                      Image name (default: $docker_image)."
        echo "         --no-sudo                         Dont use 'sudo' to run docker."
        echo "     -p, --port-range $port_range          Exposes container port range into host using format FIRST:LAST."
        echo "     -r, --run-as-root                     Run container as root."
        echo "     -s, --standalone                      Start from standalone dir \`./standalone\`."
    fi

    if [ -z "$command" ] || [ "$command" == "sync-template" ]; then
        echo "$COLOR_GREEN"
        echo "  -> sync-template [CLUSTER-DIR]   Sync files from ./templates/\$type into CLUSTER-DIR." "$COLOR_RESET"
        echo "         --force                    Force template sync."
    fi

    if [ -z "$command" ] || [ "$command" == "remote-setup" ]; then
        echo "$COLOR_GREEN"
        echo "  -> remote-setup [OPTIONS...]    Update local repo's remote upstream." "$COLOR_RESET."
        echo "     -f, --flux-git-repo URL    Define flux git repository address. Defaults to ORIGIN. (format: ssh://user@host/path/to/repo)."
        echo "     -o, --origin REMOTE          Define ORIGIN remote address."
        echo "     -u, --upstream REMOTE        Define UPSTREAM remote address (default: $default_upstream)."
    fi

    if [ -z "$command" ] || [ "$command" == "update-ssh-key" ]; then
        echo "$COLOR_GREEN"
        echo "  -> update-ssh-key [CLUSTER-DIR]    Creates a new ssh key (doesn't pushes to git repo)." "$COLOR_RESET"
        echo "     -k, --ssh-key-type              New SSH key type (default: $ssh_key_type)."
        echo "     -l, --ssh-key-length            SSH key length, depends on ssh key type."
    fi

#    if [ -z "$command" ] || [ "$command" == "import-variables" ]; then
#        echo "$COLOR_GREEN"
#        echo "  -> import-variables [PREFIX SOURCE]...  Adds PREFIX to terraform variables from SOURCE." "$COLOR_RESET"
#    fi

    if [ -z "$command" ]; then
        echo
        echo "  SSH default key lengths:"
        echo "    rsa: $ssh_key_length_rsa"
        echo "    dsa: $ssh_key_length_dsa"
        echo "    ecdsa: $ssh_key_length_ecdsa"
    fi

    if [ $# -gt 0 ]; then
        echo
        echo -e "${COLOR_RED}$@${COLOR_RESET}"
        exit_code=1
    fi

    exit ${exit_code:-0}
}

function invalid_argument()
{
    case "$1" in
        -*)
            usage "Invalid option[${BASH_LINENO[0]}]: $@"
        ;;
        *)
            usage "Invalid or missing parameter[${BASH_LINENO[0]}]: $@"
    esac
}

function dump_options()
{
    echo Current options:
    for i in command debug verbose force ssh_key_type ssh_key_length \
        standalone docker_command port_range run_as_root \
        force_docker_image_build cluster_dir \
        import_var_prefixes import_var_sources
        do
        echo "  ${!i@A}"
    done
}


##########
## MAIN ##
##########

# defaults
command=''
cluster_dir=""
debug=false
verbose=false
force=false
ssh_key_length_rsa=4096
ssh_key_length_dsa=1024
ssh_key_length_ecdsa=521
ssh_key_type=ecdsa
ssh_key_length=0
default_upstream=git@github.com:getupcloud/managed-cluster.git
common_template_files=(
    templates/manifests
    templates/*.*
    templates/.gitignore
)

#####################
## COMMAND: create ##
#####################

opt_origin=
opt_upstream=
opt_customer=
opt_name=
opt_type=
opt_flux_git_repo=

alias getopt_c=getopt_create
function getopt_create()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            -f|--flux-git-repo)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_flux_git_repo=$1
            ;;
            -o|--origin)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_origin=$1
            ;;
            -u|--upstream)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_upstream=$1
            ;;
            -c|--customer)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_customer=$1
            ;;
            -n|--name)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_name=$1
            ;;
            -t|--type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_type=$1
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            -l|--ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi
}

alias command_c=command_create
function command_create()
{
    set -e

    if ! [ -e "$REPO_CONFIG" ]; then
        create_repo_config
    fi

    create_cluster

    if ! has_remote upstream; then
        line
        info Current remotes:
        git remote -v

        update_git_remotes

        line
        info New remotes:
        git remote -v
    fi
}

function create_repo_config()
{
    info Creating $REPO_CONFIG

    read_config customer "Customer name"

    local current_upstream=$(git_remote upstream)
    [ -z "$upstream" ] && upstream="$origin"
    [ -z "$upstream" ] && upstream="$current_upstream"
    [ -z "$upstream" ] && upstream="$default_upstream"
    read_config upstream "Set UPSTREAM remote"

    [ -z "$origin" ] && origin="$(git-url $(git_remote origin) url2ssh)"
    origin=${origin%.git}-$customer.git
    read_config origin "Set ORIGIN remote"

    flux_git_repo=${origin#git://}
    flux_git_repo=ssh://${flux_git_repo/:/\/}
    read_config flux_git_repo "Flux git repository"

    save_repo_config
}

function save_repo_config()
{
    set_config customer="$customer" "Customer name" $REPO_CONFIG
    set_config upstream="$upstream" "Upstream git repo" $REPO_CONFIG
    set_config origin="$origin" "Origin git repo" $REPO_CONFIG
    set_config flux_git_repo="$flux_git_repo" "Git repo for default flux GitRepository" $REPO_CONFIG
}

function create_cluster()
{
    select_cluster_type
    read_config name "Cluster name"

    local cluster_root_dir=clusters/$name
    cluster_dir=$cluster_root_dir/$type
    export CLUSTER_CONFIG=$cluster_dir/cluster.conf

    mkdir -p ${cluster_dir}
    save_cluster_config
    copy_from_template templates/$type $cluster_dir
    generate_ssh_key
}

function save_cluster_config()
{
    set_config type="$type" "Cluster Type" $CLUSTER_CONFIG
    set_config name="$name" "Cluster Name" $CLUSTER_CONFIG
}

####################
## COMMAND: start ##
####################

standalone=false
docker_command="" # /bin/bash
port_range=32000-32010
run_as_root=false
docker_image=ghcr.io/getupcloud/managed-cluster:$(cat ${ROOT_DIR}/version.txt)
force_docker_image_build=false
sudo=sudo

alias getopt_s=getopt_start
function getopt_start()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -s|--standalone)
                standalone=true
            ;;
            -P|--port-range)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                port_range=$1
            ;;
            -r|--run-as-root)
                run_as_root=true
            ;;
            --no-sudo)
                sudo=""
            ;;
            -i|--image)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                docker_image=$1
            ;;
            --force-docker-image-build)
                force_docker_image_build=true
            ;;
            --)
                shift
                docker_command="${@@Q}"
                shift $#
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    cluster_dir=$(select_cluster $cluster_dir)
}

function check_dependencies()
{
    local status=0

    for bin in jq make; do
        if ! which $bin &>/dev/null; then
            warn "Missing required command: $bin"
            status=1
        fi
    done

    for lib in giturlparse; do
        if ! python3 -c "import $lib; print($lib)" &>/dev/null && ! python -c "import $lib; print($lib)" &>/dev/null; then
            warn "Missing required python lib: $lib"
            status=1
        fi
    done

    return $status
}

function check_deprecations()
{
    local old_cluster_configs=(
        upstream_git_repo
        origin_git_repo
        https_origin_git_repo
        flux_git_repo
    )

    for i in ${old_cluster_configs[*]}; do
        if grep -q $i $cluster_dir/cluster.conf; then
            warn "DEPRECATED: $cluster_dir/cluster.conf: $i: Please remove this config."
        fi
    done
}

alias command_s=command_start
function command_start()
{
    check_deprecations

    if ! check_dependencies; then
        info "Execute 'make install' or install missing command(s) or lib(s)"
        exit 1
    fi

    if $standalone; then
        cluster_dir="$PWD/standalone"
        mkdir -p $cluster_dir
        touch $cluster_dir/cluster.conf
        touch $cluster_dir/terraform.tfvars
    fi

    start_container
}

############################
## COMMAND: sync-template ##
############################

alias getopt_st=getopt_sync_template
function getopt_sync_template()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    cluster_dir=$(select_cluster $cluster_dir)
}

alias command_st=command_sync_template
function command_sync_template()
{
    assert_cluster_dir
    sync_from_template
}

###########################
## COMMAND: remote-setup ##
###########################

opt_upstream=
opt_origin=

alias getopt_rs=getopt_remote_setup
function getopt_remote_setup()
{
    while [ $# -gt 0 ]; do
        case $1 in
            --force)
                force=true
            ;;
            -o|--origin)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_origin=$1
            ;;
            -u|--upstream)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_upstream=$1
            ;;
            -f|--flux-git-repo)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_flux_git_repo=$1
        esac
        shift
    done
}

alias command_rs=command_remote_setup
function command_remote_setup()
{
    set -e
    line
    info Current remotes:
    git remote -v

    source_env $REPO_CONFIG

    echo "$opt_upstream$opt_origin$opt_flux_git_repo"
    if [ -z "$opt_upstream$opt_origin$opt_flux_git_repo" ]; then
        read_config upstream "Set UPSTREAM remote"
        read_config origin "Set ORIGIN remote"
        read_config flux_git_repo "Flux git repository"
    else
        [ -z "$opt_upstream" ] || read_config upstream "Set UPSTREAM remote"
        [ -z "$opt_origin" ] || read_config origin "Set ORIGIN remote"
        [ -z "$opt_flux_git_repo" ] || read_config flux_git_repo "Flux git repository"
    fi

    line
    info Will update to:
    info "-> upstream: $upstream"
    info "-> origin: $origin"
    info "-> flux_git_repo: $flux_git_repo"

    if ! $force; then
        if ! ask "Continue? [Y/n]"; then
            return
        fi
    fi

    save_repo_config
    update_git_remotes

    line
    info New remotes:
    git remote -v
}

#############################
## COMMAND: update-ssh-key ##
#############################

alias getopt_usk=getopt_update_ssh_key
function getopt_update_ssh_key()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            -l|--ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            --force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi

    cluster_dir=$(select_cluster $cluster_dir)
}

alias command_usk=command_update_ssh_key
function command_update_ssh_key()
{
    if ! $force; then
        if ! ask "Generate new ssh keys now for $cluster_dir? [Y/n]"; then
            return
        fi
    fi

    if [ -e $cluster_dir/identity ]; then
        local bkp=$cluster_dir/identity.bkp$(date +%s)
        info Renaming existing ssh key $cluster_dir/identity to $bkp
        mv $cluster_dir/identity $bkp
    fi

    generate_ssh_key
}

###############################
## COMMAND: import-variables ##
###############################

import_var_prefixes=()
import_var_sources=()

alias getopt_iv=getopt_import_variables
function getopt_import_variables()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            *)
                [ $# -lt 2 ] && invalid_argument "missing source"
                import_var_prefixes+=( "$1" )
                import_var_sources+=( "$2" )
                shift
            ;;
        esac
        shift
    done
}

function prepend_prefix()
{
    local prefix="$1"
    local source="$2"

    echo "## Starting - auto-generated by $0 from $source"
    sed -e '/^\s*variable\s\+"\?'$prefix'_/!s/^\(\s*variable\s\+"\)\?\([a-zA-Z0-9]\+\)/\1'$prefix'_\2/'
    echo "## Finished - auto-generated by $0 from $source"
}

alias command_iv=command_import_variables
function command_import_variables()
{
    for i in $(seq 0 $(( ${#import_var_prefixes[*]} - 1 )) ); do
        prefix=${import_var_prefixes[$i]}
        source=${import_var_sources[$i]}

        if [[ "$source" =~ ^https?:// ]]; then
            curl -skL "$source" | prepend_prefix "$prefix" "$source"
        elif [ "$source" == "-" ] || [ -e "$source" ]; then
            cat "$source" | prepend_prefix "$prefix" "$source"
        else
            echo "File not found: $source"
            exit 1
        fi
    done
}

##########
## Main ##
##########

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            usage
        ;;
        -d|--debug)
            debug=true
            verbose=true
        ;;
        -v|--verbose)
            verbose=true
        ;;
        --)
            break
        ;;
        -*)
            invalid_argument $1
        ;;
        *)
            if [ -z "$command" ]; then
                command=$1
                shift
                break
            else
                exit_code=1
                usage
            fi
    esac
    shift
done

if [ -z "$command" ]; then
    #invalid_argument "COMMAND"
    usage
    exit 1
fi

eval getopt_${command//-/_} "$@"


$debug && set -x
$verbose && dump_options

eval command_${command//-/_}
