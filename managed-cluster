#!/bin/bash

${DEBUG:-false} && set -x

ROOTDIR=$(readlink -ne $(dirname $0))
source $ROOTDIR/root/etc/profile.d/getup.sh
export PATH="$PATH:$PWD/root/usr/local/bin/"

if [ -t 0 ]; then
    COLOR_RED="$(tput setaf 1)"
    COLOR_GREEN="$(tput setaf 2)"
    COLOR_YELLOW="$(tput setaf 3)"
    COLOR_BOLD="$(tput bold)"
    COLOR_RESET="$(tput sgr0)"
fi

function copy_from_template()
{
    if [ $# -lt 2 ]; then
      warn "Invalid or missing parameters: $0 [src-dir] [dest-dir] [rsync-params]"
      return 1
    fi

    local src=$1
    local dest=$2
    shift 2
    local rsync_params="$@"

    if ! [ -d "$src" ]; then
      warn "Source dir not found: $src"
      return 1
    fi

    if ! [ -d "$dest" ]; then
      mkdir -p "$dest"
    fi

    rsync -va $rsync_params $src/ templates/manifests templates/*.* "$dest"
}

function sync_from_template()
{
    local dest=$cluster_dir

    if ! [ -d "$dest" ]; then
      warn "Cluster dir not found: $dest"
      return 1
    fi

    if ! [ -e "$dest/cluster.conf" ]; then
      warn "Missing $dest/cluster.conf"
      return 1
    fi

    source $dest/cluster.conf || return 1

    if [ -z "$customer" ] || [ -z "$name" ] || [ -z "$type" ]; then
      warn "Invalid $dest/cluster.conf: ${customer@A} ${name@A} ${type@A}"
      return 1
    fi

    local src=templates/$type

    if ! [ -d "$src" ]; then
      warn "Template dir not found: $src"
      return 1
    fi

    if ! $force; then
        if ! ask "Copy from $src to $dest? [Y/n]"; then
            return 0
        fi
    fi

    copy_from_template $src $dest --exclude=manifests/cluster/ --exclude=manifests/base/kustomization.yaml --exclude=\*.swp
}

function require_config()
{
    local _name="${1}"
    local _description="$2"

    # use value if already exists
    if [ -n "${!_name}" ]; then
        set_config ${_name}="${!_name}" "$_description"
        return 0
    fi

    until read_config "$@"; do
        warn "Value can't be empty"
    done

    local _value="${!_name}"
    if grep -q "\s" <<<$_value; then
        set_config "$_name='$_value'" "$_description"
    else
        set_config "$_name=$_value" "$_description"
    fi
}

function list_cluster_types()
{
    local types=( templates/*/ )
    types=( ${types[@]#*/} )
    types=( ${types[@]%/} )
    types=( "${types[@]/manifests}" ) ## remove manifests from types
    echo ${types[*]}
}

function select_cluster_type()
{
    # use value if already exists
    if [ -n "$type" ]; then
        set_config type=$type "Cluster type. One of dir names from ./templates/"
        return 0
    fi

    local types=$(list_cluster_types)
    local PS3=$(prompt "Select cluster type")

    select type in ${types}; do
        break;
    done

    export template=templates/$type
    set_config type=$type "Cluster type."
}

function generate_ssh_key()
{
    if ! [ -e $cluster_dir/identity ]; then
        info Generating $cluster_dir/identity
        ssh-keygen -t $ssh_key_type -b $ssh_key_length -f $cluster_dir/identity -N "" -C "$customer/$name/$type"
        ssh-keygen -yf $cluster_dir/identity > $cluster_dir/identity.pub
    else
        info Using existing $cluster_dir/identity
    fi

    info Generating $cluster_dir/known_hosts
    ssh-keyscan github.com > $cluster_dir/known_hosts
}

function select_cluster()
{
    local cluster_dir=""

    if [ $# -eq 0 ]; then
        local clusters=( clusters/*/*/ )
    else
        clusters=( $@ )
    fi

    clusters=( ${clusters[*]%/} )

    export config_file

    if [ ${#clusters[*]} -eq 1 ]; then
        config_file=$clusters/cluster.conf
        if ! has_valid_config $config_file; then
            warn Config not found: $config_file
            return 1
        fi

        echo -n ${clusters}
        return
    fi

    cluster_names=( ${clusters[*]#*/} )
    cluster_names=( ${cluster_names[*]%/*} )
    cluster_types=( ${clusters[*]##*/} )

    if type dialog &>/dev/null; then
        exec 3>.tmp
        eval dialog --output-fd 3 --menu "'Select cluster'" 0 0 0 \
            "$(for i in $(seq 0 $(( ${#clusters[*]} - 1 )) ); do echo -n " $i '[${cluster_types[$i]}] ${cluster_names[$i]}'"; done)" \
            '---' '---' \
            b "'Bootstrap cluster'"  >&2
            #s 'Sync from template' >&2
        idx=$(<.tmp)
        rm -f .tmp
        case "$idx" in
            [0-9]*)
                cluster_dir=${clusters[$idx]}
            ;;
            *) cluster_dir=$idx
        esac
    else
        local PS3="${COLOR_GREEN}${COLOR_BOLD}Select cluster to start: ${COLOR_RESET} "

        select cluster_dir in ${clusters[*]}; do
            config_file=$cluster_dir/cluster.conf
            if has_valid_config $cluster_dir; then
                break
            else
                warn Config not found: $config_file
            fi
        done
    fi

    echo $cluster_dir
}

function assert_cluster_dir()
{
    if ! [ -e "$cluster_dir/cluster.conf" ]; then
        warn "Invalid cluster dir: $cluster_dir"
        exit 1
    fi
}

function start_container()
{
    assert_cluster_dir

    if $run_as_root; then
        : ${CONTAINER_USER:=root}
        : ${CONTAINER_GROUP:=root}
        : ${CONTAINER_USER_ID:=0}
        : ${CONTAINER_GROUP_ID:=0}
        : ${CONTAINER_HOME:=/root}
    else
        : ${CONTAINER_USER:=$(id -un)}
        : ${CONTAINER_GROUP:=$(id -gn)}
        : ${CONTAINER_USER_ID:=$(id -u)}
        : ${CONTAINER_GROUP_ID:=$(id -g)}
        : ${CONTAINER_HOME:=/home/$CONTAINER_USER}
    fi

    local docker_image_repo=${docker_image_repo:-ghcr.io/getupcloud/cluster}
    local docker_image_tag=${docker_image_tag:-$(cat version.txt)}
    local docker_image=${docker_image_repo}:${docker_image_tag}
    local docker_run_options_defaults=(
        --cap-add=SYS_PTRACE
        #--userns host
        --network host
        #--user $CONTAINER_USER_ID:$CONTAINER_GROUP_ID
        --rm
        -it
        --env HOME=${CONTAINER_HOME}
        --env-file $ROOTDIR/.dockerenv
        -v $(readlink -ne $cluster_dir):/cluster
        -v $ROOTDIR:/repo
        -v $HOME:/home/_host:ro
    )

    if [ "$type" == kind ]; then
        docker_run_options_defaults+=(
            -v /var/run/docker.sock:/var/run/docker.sock
        )
    fi

    {
        echo CONTAINER_USER=$CONTAINER_USER
        echo CONTAINER_GROUP=$CONTAINER_GROUP
        echo CONTAINER_USER_ID=$CONTAINER_USER_ID
        echo CONTAINER_GROUP_ID=$CONTAINER_GROUP_ID
        echo CONTAINER_HOME=$CONTAINER_HOME
        echo GH_TOKEN=$GH_TOKEN
    } > .dockerenv

    if $force_docker_image_build; then
        make
    else
        if docker inspect ${docker_image_repo}:${docker_image_tag} &>/dev/null; then
            local dockerfile_modified_ts=$(stat --format %Y Dockerfile)
            local image_created=$(docker inspect ${docker_image_repo}:${docker_image_tag} | jq -r '.[].Created')
            local image_created_ts=$(date --date="$image_created" +%s)

            if (( dockerfile_modified_ts > image_created_ts )); then
                if ask "Docker image ${docker_image_repo}:${docker_image_tag} is outdated. Build now? [Y/n]"; then
                    make
                fi
            fi
        fi
    fi

    info Starting cluster: $cluster_dir with docker image ${docker_image}
    docker_run="docker run ${docker_run_options_defaults[@]} ${docker_image_repo}:${docker_image_tag} ${docker_command}"
    info \$ $docker_run
    echo
    eval sudo $docker_run
}

###########
## Start ##
###########

function usage()
{
    echo "Usage: $0 COMMAND [OPTIONS...] "
    echo
    echo "Creates and manage CLUSTER-DIR (./clusters/\$name/\$type/) from outside manager container."
    if [ -z "$command" ]; then
        echo
        echo "Available commands and options:"
        echo
        echo "    -h, --help       This help message."
        echo "    -d, --debug      Turn bash debug messages on (set -x). Implies --verbose."
        echo "    -v, --verbose    Turn verbose messages on."
    else
        echo
        echo "Run \`$0 --help\` for full help."
    fi

    if [ -z "$command" ] || [ "$command" == "create-cluster" ]; then
        echo "$COLOR_GREEN"
        echo "  -> create-cluster          Creates a new cluster from ./templates/\$type into CLUSTER-DIR (./clusters/\$name/\$type/)." "$COLOR_RESET"
        echo "     -c, --customer NAME     Customer name."
        echo "     -n, --name NAME         Unique name for new cluster."
        echo "     -t, --type NAME         Cluster type: $(list_cluster_types)."
        echo "     -k, --ssh-key-type      SSH key type (default: $ssh_key_type)."
        echo "     -l, --ssh-key-length    SSH key length, depends on ssh key type."
        echo "     -f, --force             Force create even if CLUSTER-DIR exists."
    fi

    if [ -z "$command" ] || [ "$command" == "start" ]; then
        echo "$COLOR_GREEN"
        echo "  -> start [CLUSTER-DIR] [-- params...]    Start container for a cluster, passing optional \`docker run -- params\`." "$COLOR_RESET"
        echo "     -s, --standalone                      Start from standalone dir \`./standalone\`."
        echo "     -p, --port-range $port_range          Exposes container port range into host using format FIRST:LAST."
        echo "     -r, --run-as-root                     Run container as root."
        echo "     -f, --force-docker-image-build        Force building local docker image."
    fi

    if [ -z "$command" ] || [ "$command" == "sync-templates" ]; then
        echo "$COLOR_GREEN"
        echo "  -> sync-templates [CLUSTER-DIR]   Sync files from ./templates/\$type into CLUSTER-DIR" "$COLOR_RESET"
        echo "     -f, --force                    Force template sync."
    fi

    if [ -z "$command" ] || [ "$command" == "set-upstream" ]; then
        echo "$COLOR_GREEN"
        echo "  -> set-upstream [CLUSTER-DIR]    Update local repo's remote upstream." "$COLOR_RESET"
        echo "     -r, --remote REMOTE           Define upstream remote address (default: $remote_upstream)"
    fi

    if [ -z "$command" ] || [ "$command" == "update-ssh-key" ]; then
        echo "$COLOR_GREEN"
        echo "  -> update-ssh-key [CLUSTER-DIR]    Creates a new ssh key (doesn't pushes to git repo)." "$COLOR_RESET"
        echo "     -k, --ssh-key-type              New SSH key type (default: $ssh_key_type)."
        echo "     -l, --ssh-key-length            SSH key length, depends on ssh key type."
    fi

    if [ -z "$command" ]; then
        echo
        echo "  SSH default key lengths:"
        echo "    rsa: $ssh_key_length_rsa"
        echo "    dsa: $ssh_key_length_dsa"
        echo "    ecdsa: $ssh_key_length_ecdsa"
    fi

    if [ $# -gt 0 ]; then
        echo
        echo -e "${COLOR_RED}$@${COLOR_RESET}"
        exit_code=1
    fi

    exit ${exit_code:-0}
}

function invalid_argument()
{
    case "$1" in
        -*)
            usage "Invalid option[${BASH_LINENO[0]}]: $@"
        ;;
        *)
            usage "Invalid or missing parameter[${BASH_LINENO[0]}]: $@"
    esac
}

function dump_options()
{
    echo Current options:
    for i in command debug verbose force ssh_key_type ssh_key_length \
        standalone docker_command port_range run_as_root \
        force_docker_image_build cluster_dir; do
        echo "  ${!i@A}"
    done
}


##########
## MAIN ##
##########

# defaults
command=''
cluster_dir=""
debug=false
verbose=false
force=false
ssh_key_length_rsa=4096
ssh_key_length_dsa=1024
ssh_key_length_ecdsa=521
ssh_key_type=ecdsa
ssh_key_length=0


#############################
## COMMAND: create-cluster ##
#############################

function getopt_create_cluster()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -f|--force)
                force=true
            ;;
            -c|--customer)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                customer=$1
            ;;
            -n|--name)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                name=$1
            ;;
            -t|--type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                type=$1
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            -l|--ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi
}

function command_create_cluster()
{
    export config_file=${1:-$ROOTDIR/.cluster.conf}

    if [ -e $config_file ]; then
        debug Reading config from temporary file: $config_file
        source $config_file
    else
        echo Creating temporary config: $config_file
        touch $config_file
    fi

    set -e

    require_config customer "Customer name"
    require_config name "Cluster name"
    select_cluster_type

    GIT_VERSION=$(git version | awk '{print $NF}')
    case $GIT_VERSION in
        1.*)
            set_config upstream_git_repo=$(git remote -v | grep -m1 ^origin|awk '{print $2}') "Upstream SSH git repo"
            ;;
        2.*)
            set_config upstream_git_repo=$(git remote get-url origin) "Upstream SSH git repo"
    esac

    local _origin_git_repo=$(git-url $upstream_git_repo url2ssh)
    set_config origin_git_repo=${_origin_git_repo%.git}-$customer.git "Origin SSH git repo"
    set_config https_origin_git_repo=$(git-url $origin_git_repo url2https) "Origin HTTPS git repo"

    local _git_repo=${origin_git_repo#git://}
    _git_repo=ssh://${origin_git_repo/:/\/}
    set_config flux_git_repo=${_git_repo} "Git repo for default flux GitRepository"

    local cluster_root_dir=clusters/$name
    cluster_dir=$cluster_root_dir/$type

    if [ -d $cluster_dir ] && ! $force; then
        warn "Cluster already exists: $cluster_dir"
        exit 1
    fi

    mkdir -p ${cluster_root_dir}
    copy_from_template templates/$type $cluster_dir

    local temp_config_file=$config_file
    config_file=$cluster_dir/cluster.conf

    info Moving $temp_config_file to $config_file
    mv $temp_config_file $config_file

    generate_ssh_key
}

####################
## COMMAND: start ##
####################

standalone=false
docker_command=/bin/bash
port_range=32000-32010
run_as_root=false
force_docker_image_build=false

function getopt_start()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -s|--standalone)
                standalone=true
            ;;
            -P|--port-range)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                port_range=$1
            ;;
            -r|--run-as-root)
                run_as_root=true
            ;;
            -f|--force-docker-image-build)
                force_docker_image_build=true
            ;;
            --)
                shift
                docker_command="${@@Q}"
                shift $#
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    cluster_dir=$( select_cluster $cluster_dir )
}

function command_start()
{
    if $standalone; then
        cluster_dir="$PWD/standalone"
        mkdir -p $cluster_dir
        touch $cluster_dir/cluster.conf
        touch $cluster_dir/terraform.tfvars
    fi

    assert_cluster_dir
    start_container ${docker_command}
}

############################
## COMMAND: sync-template ##
############################

function getopt_sync_templates()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -f|--force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    cluster_dir=$( select_cluster $1 )
}

function command_sync_templates()
{
    assert_cluster_dir
    sync_from_template
}

###########################
## COMMAND: set-upstream ##
###########################

remote_upstream=git@github.com:getupcloud/managed-cluster.git

function getopt_set_upstream()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -r|--remote)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                remote_upstream=$1
            ;;
            -f|--force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    cluster_dir=$( select_cluster $1 )
}

function command_set_upstream()
{
    set -e
    assert_cluster_dir

    source_env $cluster_dir/cluster.conf

    if git remote | grep -q '^upstream$'; then
        if $force; then
            info Removing old remote: upstream $remote_upstream
            git remote remove upstream
        else
            warn Remote already exists: upstream $remote_upstream
            return 1
        fi
    fi

    info Adding remote: upstream $remote_upstream
    git remote add upstream $remote_upstream
    git remote set-url --push upstream FORBIDEN
}

#############################
## COMMAND: update-ssh-key ##
#############################

function getopt_update_ssh_key()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            -l|--ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            -f|--force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi

    cluster_dir=$( select_cluster $1 )
}

function command_update_ssh_key()
{
    if ! $force; then
        if ! ask "Generate new ssh keys now for $cluster_dir? [Y/n]"; then
            return
        fi
    fi

    if [ -e $cluster_dir/identity ]; then
        local bkp=$cluster_dir/identity.bkp$(date +%s)
        info Renaming existing ssh key $cluster_dir/identity to $bkp
        mv $cluster_dir/identity $bkp
    fi

    generate_ssh_key
}

##########
## Main ##
##########

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            usage
        ;;
        -d|--debug)
            debug=true
            verbose=true
        ;;
        -v|--verbose)
            verbose=true
        ;;
        --)
            break
        ;;
        -*)
            invalid_argument $1
        ;;
        *)
            if [ -z "$command" ]; then
                command=$1
                shift
                break
            else
                exit_code=1
                usage
            fi
    esac
    shift
done

if [ -z "$command" ]; then
    invalid_argument "COMMAND"
fi

eval getopt_${command//-/_} "$@"


$debug && set -x
$verbose && dump_options

eval command_${command//-/_}
