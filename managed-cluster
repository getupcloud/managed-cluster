#!/usr/bin/env bash

${DEBUG:=false} && set -x
: ${INSIDE_CONTAINER:=false}

if [ -d /opt/homebrew/Cellar/coreutils/9.0/libexec/gnubin ]; then
    export PATH="/opt/homebrew/Cellar/coreutils/9.0/libexec/gnubin:$PATH"
fi

if $INSIDE_CONTAINER; then
    export ROOT_DIR=$REPO_DIR
    source /etc/profile.d/getup.sh
else
    export ROOT_DIR=$(readlink -nf $(dirname $0))
    export REPO_DIR=$ROOT_DIR
    export PATH="$PATH:$ROOT_DIR/root/usr/local/bin/"

    # Globals set in getup.sh:
    # REPO_DIR: git repo root dir, or from docker image envs
    # REPO_CONF: file path to repo.conf
    # CLUSTER_CONF: file path fo cluster.conf
    # TEMPLATES_DIR: dir path to $REPO_DIR/templates/
    source $ROOT_DIR/root/etc/profile.d/getup.sh
fi

if [ -t 0 ]; then
    COLOR_RED="$(tput setaf 1)"
    COLOR_GREEN="$(tput setaf 2)"
    COLOR_YELLOW="$(tput setaf 3)"
    COLOR_BOLD="$(tput bold)"
    COLOR_RESET="$(tput sgr0)"
fi

function usage()
{
    echo "Managed Cluster - v$current_version"
    echo "Usage: $0 COMMAND [OPTIONS...] "
    echo "Create and manage kubernetes clusters. Each customer have one repository, with one or more clusters inside \$CLUSTER-DIR (./clusters/\$cluster_name/\$cluster_type/)."
    if [ -z "$command" ]; then
        echo
        echo "Available commands and options:"
        echo
        echo "    -d, --debug            Turn bash debug messages on (set -x). Implies --verbose."
        echo "    -h, --help             This help message."
        echo "    -v, --verbose          Turn verbose messages on."
        echo "    -U, --no-check-update  Do not check for updates from upstream repo (default: false)."
    else
        echo
        echo "Run \`$0 --help\` for full help."
    fi

    if [ -z "$_command" ] || [ "$_command" == "create" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> create [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Creates a new cluster from ./templates/\$cluster_type into CLUSTER-DIR (./clusters/\$cluster_name/\$cluster_type/)." "$COLOR_RESET"
        echo
        echo "     -c, --customer-name NAME       Customer name."
        echo "         --force                    Force create even if CLUSTER-DIR exists."
        echo "     -f, --flux-git-repo URL        Define flux git repository address. Defaults to ORIGIN. (format: ssh://user@host/path/to/repo)."
        echo "     -l, --local-git-repo           Use cluster-internal git server '$local_git_repo'. (default: false)"
        echo "     -k, --ssh-key-type             SSH key type (default: $ssh_key_type)."
        echo "         --ssh-key-length           SSH key length, depends on ssh key type."
        echo "     -H, --ssh-host                 SSH host (default: $ssh_host)."
        echo "     -n, --cluster-name NAME        Unique name for new cluster."
        echo "     -o, --origin REMOTE            Overwrite ORIGIN remote address (default: $default_origin_fmt)."
        echo "     -p, --cluster-provider NAME    Cluster provider: $CLUSTER_PROVIDERS."
        echo "     -s, --cluster-sla VALUE        Cluster SLA: high, low, none (default: $opt_cluster_sla)."
        echo "     -t, --cluster-type NAME        Cluster type: $CLUSTER_TYPES."
        echo "     -u, --upstream REMOTE          Overwrite UPSTREAM remote address (default: $default_upstream)."
    fi

    if [ -z "$_command" ] || [ "$_command" == "create-repo" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> create-repo [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Createa a new repository without creating any cluster." "$COLOR_RESET"
        echo
        echo "     -c, --customer-name NAME       Customer name."
        echo "     -f, --flux-git-repo URL        Define flux git repository address. Defaults to ORIGIN. (format: ssh://user@host/path/to/repo)."
        echo "     -l, --local-git-repo           Use cluster-internal git server '$local_git_repo'. (default: false)"
        echo "     -k, --ssh-key-type             SSH key type (default: $ssh_key_type)."
        echo "         --ssh-key-length           SSH key length, depends on ssh key type."
        echo "     -H, --ssh-host                 SSH host (default: $ssh_host)."
        echo "     -o, --origin REMOTE            Overwrite ORIGIN remote address (default: $default_origin_fmt)."
        echo "     -p, --cluster-provider NAME    Cluster provider: One of $CLUSTER_PROVIDERS."
        echo "     -u, --upstream REMOTE          Overwrite UPSTREAM remote address (default: $default_upstream)."
    fi

    if [ -z "$_command" ] || [ "$_command" == "start" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> start [CLUSTER-DIR] [OPTIONS...] [--] [params...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Start container for a cluster, passing optional \`docker run -- params\`." "$COLOR_RESET"
        echo
        echo "     -e, --env-file FILE                   Export environment files from FILE (file format: name=\"value\")"
        echo "         --force-docker-image-build        Force building local docker image."
        echo "     -i, --image NAME                      Image name (default: $(get_docker_image))."
        echo "         --no-sudo                         Dont use 'sudo' to run docker."
        echo "     -p, --port-range $port_range          Exposes container port range into host using format FIRST:LAST."
        echo "     -r, --run-as-root                     Run container as root."
        echo "     -s, --standalone                      Start from standalone dir \`./standalone\`."
    fi

    if [ -z "$_command" ] || [ "$_command" == "repo_pull" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> repo-pull" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Pulls from both remotes 'upstream' and 'origin'." "$COLOR_RESET"
    fi

    if [ -z "$_command" ] || [ "$_command" == "update" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> update" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Fetch 'upstream' remote and merge from a newer version." "$COLOR_RESET"
        echo
        echo "         --force                    Force version check."
    fi

    if [ -z "$_command" ] || [ "$_command" == "sync_template" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> sync-template [CLUSTER-DIR] [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Sync files from ./templates/\$cluster_type into CLUSTER-DIR." "$COLOR_RESET"
        echo
        echo "         --force                    Force template sync."
    fi

    if [ -z "$_command" ] || [ "$_command" == "remote_setup" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> remote-setup [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Update local remote upstream." "$COLOR_RESET"
        echo
        echo "     -f, --flux-git-repo URL    Define flux git repository address. Defaults to ORIGIN. (format: ssh://user@host/path/to/repo)."
        echo "     -l, --local-git-repo       Use cluster-internal git server '$local_git_repo'. (default: false)"
        echo "     -o, --origin REMOTE        Define ORIGIN remote address."
        echo "     -u, --upstream REMOTE      Define UPSTREAM remote address (default: $default_upstream)."
    fi

    if [ -z "$_command" ] || [ "$_command" == "update_ssh_key" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> update-ssh-key [CLUSTER-DIR] [OPTIONS...]" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Creates a new ssh key (doesn't pushes to git repo)." "$COLOR_RESET"
        echo
        echo "     -k, --ssh-key-type              New SSH key type (default: $ssh_key_type)."
        echo "     -l, --ssh-key-length            SSH key length, depends on ssh key type."
    fi

    if [ -z "$_command" ] || [ "$_command" == "install_teleport_agent" ]; then
        echo "${COLOR_BOLD}$COLOR_GREEN"
        echo "  -> install-teleport-agent" "$COLOR_RESET${COLOR_BOLD}"
        echo "     Installs teleport-agent as a systemd service" "$COLOR_RESET"
        echo
    fi

#    if [ -z "$command" ] || [ "$command" == "import-variables" ]; then
#        echo "$COLOR_GREEN"
#        echo "  -> import-variables [PREFIX SOURCE]...  Adds PREFIX to terraform variables from SOURCE." "$COLOR_RESET"
#    fi

    if [ -z "$_command" ]; then
        echo
        echo "  SSH default key lengths:"
        echo "    rsa: $ssh_key_length_rsa"
        echo "    dsa: $ssh_key_length_dsa"
        echo "    ecdsa: $ssh_key_length_ecdsa"
    fi

    if [ $# -gt 0 ]; then
        echo
        echo -e "${COLOR_RED}$@${COLOR_RESET}"
        exit_code=1
    fi

    exit ${exit_code:-0}
}

function invalid_argument()
{
    case "$1" in
        -*)
            usage "Invalid option[${BASH_LINENO[0]}]: $@"
        ;;
        *)
            usage "Invalid or missing parameter[${BASH_LINENO[0]}]: $@"
    esac
}

function dump_options()
{
    echo Current options:
    for i in command debug verbose force ssh_key_type ssh_key_length ssh_host \
        standalone docker_command port_range run_as_root \
        docker_image force_docker_image_build cluster_dir \
        import_var_prefixes import_var_sources local_git_repo
        do
        echo "  ${!i@A}"
    done
}

function copy_from_template_common()
{
    if [ -z "$TEMPLATES_DIR" ] || [ -z "$CLUSTER_DIR" ]; then
        echo "Invalid empty TEMPLATE_DIR=$TEMPLATES_DIR CLUSTER_DIR=$CLUSTER_DIR. This is a bug!"
        exit 2
    fi

    local cmd="rsync -va --checksum --omit-dir-times $@ --exclude=providers/ ${common_template_files[@]/#/$TEMPLATES_DIR/} $CLUSTER_DIR/"
    info "--> $cmd"
    $cmd
}

function copy_from_template_provider()
{
    if [ -z "$TEMPLATE_DIR" ] || [ -z "$CLUSTER_DIR" ]; then
        echo "Invalid empty TEMPLATE_DIR=$TEMPLATE_DIR CLUSTER_DIR=$CLUSTER_DIR. This is a bug!"
        exit 2
    fi

    local cmd="rsync -va --checksum --omit-dir-times $@ $TEMPLATE_DIR/ $CLUSTER_PROVIDER_DIR $CLUSTER_PROVIDER_TF $CLUSTER_DIR/"
    info "--> $cmd"
    $cmd

    if [ -d $CLUSTER_PROVIDER_DIR ]; then
        sed -i -e "s|%cluster_provider%|$cluster_provider|g" $CLUSTER_PROVIDER_TF
    fi
}

function sync_from_template()
{
    if ! [ -d "$CLUSTER_DIR" ]; then
      warn "Cluster dir not found: $CLUSTER_DIR"
      return 1
    fi

    if ! [ -e "$REPO_CONF" ]; then
      warn "Missing file: $REPO_CONF"
      return 1
    fi

    if ! [ -e "$CLUSTER_CONF" ]; then
      warn "Missing file: $CLUSTER_CONF"
      return 1
    fi

    local rsync_params="--out-format=%n --info=all0,name1 --exclude=manifests/cluster/ --exclude=group_vars/ --exclude=\*.swp"
    local files_to_sync_common=( $(copy_from_template_common $rsync_params --dry-run) )
    local files_to_sync_provider=( $(copy_from_template_provider $rsync_params --dry-run) )

    if (( ${#files_to_sync_common[*]} + ${#files_to_sync_provider[*]} == 0 )); then
        info Nothing to sync
        return
    fi

    if ! $force; then
        info "Will sync files below:"
        echo
        echo "${COLOR_BOLD}--[ Updates from $TEMPLATES_DIR ]--${COLOR_RESET}"
        echo ${files_to_sync_common[*]} | sed -e "s/\s/\n/g" #| sed -e "s/^/+ /"
        echo
        echo "${COLOR_BOLD}--[ Updates from $TEMPLATE_DIR ]--${COLOR_RESET}"
        echo ${files_to_sync_provider[*]} | sed -e "s/\s/\n/g" #| sed -e "s/^//"

        while true; do
            ask_any "Please choose an action [Yes/No/Diff]:"
            case ${ask_response,,} in
                y|yes|s|sim)
                    break
                ;;
                n|no|nao)
                    return
                ;;
                d|diff)
                    {
                        for file in ${files_to_sync_common[@]}; do
                            if [ -f "$TEMPLATES_DIR/$file" ] || [ -L "$TEMPLATES_DIR/$file" ]; then
                                diff -puN --color=always $CLUSTER_DIR/${file} $TEMPLATES_DIR/${file}
                            fi
                        done
                        for file in ${files_to_sync_provider[@]}; do
                            if [ -f "$TEMPLATE_DIR/$file" ] || [ -L "$TEMPLATE_DIR/$file" ]; then
                                diff -puN --color=always $CLUSTER_DIR/${file} $TEMPLATE_DIR/${file}
                            fi
                        done
                    } | less -rXF
                ;;
                *)
                    continue
            esac
        done
    fi

    copy_from_template_common $rsync_params
    copy_from_template_provider $rsync_params

    if ! [ -e $CLUSTER_VERSION_FILE ]; then
        info Creating $CLUSTER_VERSION_FILE: $(get_current_version)
    else
        info Updating $CLUSTER_VERSION_FILE: $(get_current_cluster_version)
    fi

    cp -f $VERSION_FILE $CLUSTER_VERSION_FILE
}

function merge_requires()
{
    local requires_txt=( $CLUSTER_DIR/requires-custom.txt $TEMPLATE_DIR/requires.txt )
    local source_requires_tf=$TEMPLATES_DIR/requires.tf
    local target_requires_tf=$CLUSTER_DIR/requires.tf
    local requires="$(cat ${requires_txt[*]} 2>/dev/null | sed -e 's|^|    |' -e 's|/|\\/|g' -e 's|$|\\|' -e '$s|$|\n|' )"

    if grep -q "# requires.txt end ${cluster_type}" $target_requires_tf; then
        return
    fi

    sed -e "/# requires.txt placeholder.*/a \
    $requires
    # requires.txt end ${cluster_type}
    " < $source_requires_tf > $target_requires_tf

    if type terraform &>/dev/null; then
        terraform fmt $target_requires_tf
    fi
}

#function require_config()
#{
#    local _name="${1}"
#    local _description="${2}"
#    local _filename="${3}"
#
#    # use value if already exists
#    if [ -n "${!_name}" ]; then
#        set_config ${_name}="${!_name}" "$_description" $_filename
#        return 0
#    fi
#
#    until read_config "$_name" "$_description"; do
#        warn "Value can't be empty"
#    done
#
#    local _value="${!_name}"
#    set_config "$_name='$_value'" "$_description" $_filename
#}

function select_cluster_type()
{
    # Cluster Type
    if [ -n "$opt_cluster_type" ]; then
        local valid=false
        for i in $CLUSTER_TYPES; do
            if [ "$opt_cluster_type" == "$i" ]; then
                export cluster_type="$opt_cluster_type"
                valid=true
                break
            fi
        done
        if ! $valid; then
            warn Invalid cluster type: $opt_cluster_type
            return 1
        fi
    else
        local types="$CLUSTER_TYPES"
        local PS3=$(prompt "Select cluster type")

        select cluster_type in ${types}; do
            break;
        done

        export cluster_type
    fi
}

function select_cluster_provider()
{
    # Cluster Provider
    if [ -n "$opt_cluster_provider" ]; then
        local valid=false
        for i in $(list_cluster_providers $cluster_type); do
            if [ "$opt_cluster_provider" == "$i" ]; then
                export cluster_provider="$opt_cluster_provider"
                valid=true
                break
            fi
        done
        if ! $valid; then
            warn Invalid cluster provider: $opt_cluster_provider
            return 1
        fi
    else
        local providers=( $(list_cluster_providers $cluster_type) )
        if [ ${#providers[*]} -gt 1 ]; then
            local PS3=$(prompt "Select cluster provider")

            select cluster_provider in ${providers[*]}; do
                break;
            done
        else
            cluster_provider=${providers[0]}
        fi

        export cluster_provider
    fi
}

function list_cluster_providers()
{
    if [ $# -gt 0 ]; then
        echo ${CLUSTER_TYPES_PROVIDERS[$1]}
    else
        echo $CLUSTER_PROVIDERS
    fi
}

function select_cluster_sla()
{
    if [ -n "$opt_cluster_sla" ]; then
        case "$opt_cluster_sla" in
            high|low|none)
                export cluster_sla=$opt_cluster_sla
                return
            ;;
        esac
        warn Invalid cluster SLA: $opt_cluster_sla
        return 1
    fi

    local PS3=$(prompt "Select cluster SLA")

    select cluster_sla in "high (prod|hlg)" "low (dev|test)" "none (no remote-ops)"; do
        cluster_sla=$(cut -f1 -d' ' <<<$cluster_sla)
        case "$cluster_sla" in
            high|low|none)
                break;
        esac
    done

    export cluster_sla
}

function set_local_git_repo()
{
    ssh_host="$local_git_repo_host"
    opt_flux_git_repo="${opt_flux_git_repo:-$local_git_repo}"

    info "Using local flux git repo: $local_git_repo"
}

function generate_ssh_key()
{
    local key_priv=$CLUSTER_DIR/identity
    local key_pub=$CLUSTER_DIR/identity.pub
    #local kh=$CLUSTER_DIR/known_hosts

    if ! [ -e $key_priv ]; then
        info "Generating $key_priv ($ssh_key_length bits)"
        ssh-keygen -t $ssh_key_type -b $ssh_key_length -f $key_priv -N "" -C "$customer_name${cluster_name:+/$cluster_name}/${cluster_type:+/$cluster_type}"
    else
        info Using existing $key_priv
    fi

    if ! [ -e $key_pub ]; then
        ssh-keygen -yf $key_priv > $key_pub
    fi

    if $opt_local_git_repo; then
      host_to_scan="127.0.0.1,$ssh_host"
    else
      host_to_scan="$ssh_host"
    fi

    #info "Generating $kh for $ssh_host"
    #echo "$host_to_scan" | ssh-keyscan -f - >$kh 2>/dev/null
    ssh-keyscan-setup
}

function select_cluster()
{
    local cluster_dir=""

    if $INSIDE_CONTAINER; then
        # already set
        return
    fi

    if [ $# -eq 0 ]; then
        local candidate_clusters=( clusters/*/*/ )
    else
        candidate_clusters=( $@ )
    fi

    candidate_clusters=( ${candidate_clusters[*]%/} )

    if [ ${#candidate_clusters[*]} -eq 0 ]; then
        warn "No cluster found. Please run '$0 create' first."
        exit 1
    elif [ ${#candidate_clusters[*]} -eq 1 ]; then
        cluster_dir="$candidate_clusters"
    else
      cluster_names=( ${candidate_clusters[*]#*/} )
      cluster_names=( ${cluster_names[*]%/*} )
      cluster_types=( ${candidate_clusters[*]##*/} )

      if type fzf &>/dev/null; then
          cluster_dir=$(printf '%s\n' ${candidate_clusters[*]} | awk '{print FNR, $0}' |
              fzf -1 --ansi --no-preview --cycle --reverse --header='---[ Select Cluster ]---' | awk '{print $2}')
      elif type dialog &>/dev/null; then
          exec 3>.tmp
          eval dialog --output-fd 3 --menu "'Select cluster'" 0 0 0 \
              "$(for i in $(seq 0 $(( ${#candidate_clusters[*]} - 1 )) ); do echo -n " $((i + 1)) '[${cluster_types[$i]}] ${cluster_names[$i]}'"; done)" \
              '---' '---' \
              b "'Bootstrap cluster'"  >&2
              #s 'Sync from template' >&2
          idx=$(<.tmp)
          rm -f .tmp
          let idx--
          case "$idx" in
              [0-9]*)
                  cluster_dir=${candidate_clusters[$idx]}
              ;;
              *) cluster_dir=$idx
          esac
      else
          local PS3="${COLOR_GREEN}${COLOR_BOLD}Select cluster to start: ${COLOR_RESET} "

          select cluster_dir in ${candidate_clusters[*]}; do
              export CLUSTER_CONF=$cluster_dir/cluster.conf
              if has_valid_config $cluster_dir; then
                  break
              else
                  warn Config not found: $CLUSTER_CONF
              fi
          done
      fi
    fi

    update_globals CLUSTER_DIR="$cluster_dir"
}

function assert_cluster_dir()
{
    if [ -z "$CLUSTER_DIR" ]; then
        warn "Missing cluster dir"
        exit 1
    fi

    if ! [ -e "$CLUSTER_CONF" ]; then
        warn "Invalid or missing cluster config: $CLUSTER_CONF"
        exit 1
    fi
}

function update_git_remotes()
{
    line
    info Updating remotes

    if [ -z "$upstream" ]; then
        warn Missing UPSTREAM remote
        return 1
    fi

    if [ -z "$origin" ]; then
        warn Missing ORIGIN remote
        return 1
    fi

    git remote remove upstream 2>/dev/null || true
    git remote add upstream "$upstream"
    git remote set-url --push upstream FORBIDEN

    git remote remove origin 2>/dev/null || true
    git remote add origin $origin
}

function get_docker_image()
{
    if [ -z "$docker_image" ]; then
        echo $default_docker_image_repo:v$(get_current_version)
    else
        echo $docker_image
    fi
}

function start_container()
{
    assert_cluster_dir

    if $run_as_root; then
        : ${CONTAINER_USER_ID:=0}
        : ${CONTAINER_GROUP_ID:=0}
    else
        : ${CONTAINER_USER_ID:=$(id -u)}
        : ${CONTAINER_GROUP_ID:=$(id -g)}
    fi

    local docker_run_options_defaults=(
        --cap-add=SYS_PTRACE
        --network host
        --rm
        -it
        --env-file $ROOT_DIR/.dockerenv
        ${env_file:+--env-file $env_file}
        -v $(readlink -nf $CLUSTER_DIR):/cluster
        -v $ROOT_DIR:/repo
        -v $HOME:/home/_host:ro
    )

    if [ -e /var/run/docker.sock ]; then
        docker_run_options_defaults+=(
            -v /var/run/docker.sock:/var/run/docker.sock
        )
        DOCKER_SOCK_GID=$(stat /var/run/docker.sock -c '%g')
    fi

    if [ -e "$SSH_AUTH_SOCK" ]; then
        docker_run_options_defaults+=(
            -v "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK"
            --env "SSH_AGENT_PID=$SSH_AGENT_PID"
            --env "SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
        )
    fi

    {
        echo CONTAINER_USER_ID=$CONTAINER_USER_ID
        echo CONTAINER_GROUP_ID=$CONTAINER_GROUP_ID
        echo DOCKER_SOCK_GID=$DOCKER_SOCK_GID
        echo GH_TOKEN=$GH_TOKEN
        echo debug=$debug
        echo verbose=$verbose
    } > .dockerenv

    if $force_docker_image_build; then
        make
    fi

    check_deprecations

    info Starting cluster: $CLUSTER_DIR with docker image ${docker_image}
    docker_run="docker run ${docker_run_options_defaults[@]} ${docker_image} ${docker_command}"
    info \$ $docker_run
    #echo
    eval $sudo $docker_run
}

##########
## MAIN ##
##########

# defaults
current_version=$(get_current_version)
command=''
cluster_dir=""
debug=false
verbose=false
force=false
no_check_update=false
ssh_key_length_rsa=4096
ssh_key_length_dsa=1024
ssh_key_length_ecdsa=521
ssh_key_type=ecdsa
ssh_key_length=0
ssh_host=github.com
local_git_repo_user=git
local_git_repo_host=git.flux-system.svc.cluster.local
local_git_repo_path=/git
local_git_repo="ssh://${local_git_repo_user}@${local_git_repo_host}${local_git_repo_path}" # port is handled by ~/.ssh/config
default_origin_fmt=git@github.com:getupcloud/managed-cluster-\${customer_name}.git
default_upstream=git@github.com:getupcloud/managed-cluster.git
default_upstream_https=https://github.com/getupcloud/managed-cluster.git
common_template_files=(
    manifests
    '*.*'
    .gitignore
)

#####################
## COMMAND: create ##
#####################

opt_origin=
opt_upstream=
opt_customer_name=
opt_cluster_name=
opt_cluster_type=
opt_cluster_provider=
opt_cluster_sla=
opt_flux_git_repo=
opt_local_git_repo=false

function getopt_c() { _command=create && getopt_create "$@"; }
function getopt_create()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            -f|--flux-git-repo)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_flux_git_repo=$1
            ;;
            -l|--local-git-repo)
                opt_local_git_repo=true
            ;;
            -o|--origin)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_origin=$1
            ;;
            -u|--upstream)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_upstream=$1
            ;;
            -c|--customer-name)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_customer_name=$1
            ;;
            -n|--cluster-name)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_cluster_name=$1
            ;;
            -p|--cluster-provider)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_cluster_provider=$1
            ;;
            -t|--cluster-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_cluster_type=$1
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            --ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            -H|--ssh-host)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_host=$1
            ;;
            -s|--cluster-sla)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_cluster_sla=$1
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done

    if $opt_local_git_repo; then
        set_local_git_repo
    fi

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi
}

function command_c() { _command=create && command_create "$@"; }
function command_create()
{
    set -e

    create_repo_config
    create_cluster

    if ! has_remote upstream; then
        line
        info Current remotes:
        git remote -v

        update_git_remotes

        line
        info New remotes:
        git remote -v
    fi
}

function create_repo_config()
{
    if [ -e "$REPO_CONF" ]; then
        info Found $REPO_CONF
        return 0
    fi

    info Creating $REPO_CONF

    read_config customer_name "Customer name"

    local current_upstream=$(git_remote upstream)
    [ -z "$upstream" ] && upstream="$origin"
    [ -z "$upstream" ] && upstream="$current_upstream"
    [ -z "$upstream" ] && upstream="$default_upstream"
    read_config upstream "Set UPSTREAM remote"

    if $opt_local_git_repo; then
        origin=${local_git_repo}
    elif [ -z "$origin" ]; then
        if [ -z "$opt_origin" ]; then
            origin="$(git-url $(git_remote origin) url2ssh)"
            origin=$(eval echo $default_origin_fmt)
        fi
        read_config origin "Set ORIGIN remote"
    fi

    flux_git_repo=${origin#git://}
    flux_git_repo=ssh://${flux_git_repo/:/\/}
    read_config flux_git_repo "Flux git repository"

    save_repo_config
}

function save_repo_config()
{
    info Saving $REPO_CONF

    set_config version="$current_version" "Installer version" $REPO_CONF
    set_config customer_name="$customer_name" "Customer name" $REPO_CONF
    set_config upstream="$upstream" "Upstream git repo" $REPO_CONF
    set_config origin="$origin" "Origin git repo" $REPO_CONF
    set_config flux_git_repo="$flux_git_repo" "Git repo for default flux GitRepository" $REPO_CONF
}

function create_cluster()
{
    select_cluster_type
    select_cluster_provider
    read_config cluster_name "Cluster name"
    select_cluster_sla

    CLUSTER_DIR="$ROOT_DIR/clusters/$cluster_name/$cluster_type"
    CLUSTER_CONF="$ROOT_DIR/clusters/$cluster_name/$cluster_type/cluster.conf"
    mkdir -p ${CLUSTER_DIR}

    update_globals CLUSTER_DIR="$CLUSTER_DIR"

    info Creating $CLUSTER_CONF

    set_config cluster_type="$cluster_type" "Cluster Type" $CLUSTER_CONF
    set_config cluster_provider="$cluster_provider" "Cluster Provider" $CLUSTER_CONF
    set_config cluster_name="$cluster_name" "Cluster Name" $CLUSTER_CONF
    set_config cluster_sla="$cluster_sla" "Cluster SLA" $CLUSTER_CONF

    update_globals

    cp $VERSION_FILE $CLUSTER_VERSION_FILE
    set_current_migration_version $(<$CLUSTER_VERSION_FILE)

    copy_from_template_common
    copy_from_template_provider
    merge_requires
    generate_ssh_key
}

##########################
## COMMAND: create-repo ##
##########################

function getopt_cr() { _command=create_repo && getopt_create_repo "$@"; }
function getopt_create_repo()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            -f|--flux-git-repo)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_flux_git_repo=$1
            ;;
            -l|--local-git-repo)
                opt_local_git_repo=true
            ;;
            -o|--origin)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_origin=$1
            ;;
            -u|--upstream)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_upstream=$1
            ;;
            -c|--customer-name)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_customer_name=$1
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            --ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            -H|--ssh-host)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_host=$1
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done

    if $opt_local_git_repo; then
        set_local_git_repo
    fi

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi
}

function command_cr() { _command=create_repo && command_create_repo "$@"; }
function command_create_repo()
{
    set -e

    create_repo_config

    if ! has_remote upstream; then
        line
        info Current remotes:
        git remote -v

        update_git_remotes

        line
        info New remotes:
        git remote -v
    fi

    #generate_ssh_key repo
    repo-setup
    repo-push
}

#####################################
## COMMAND: install-teleport-agent ##
#####################################

function getopt_ita() { _command=install_teleport_agent && getopt_install_teleport_agent "$@"; }
function getopt_install_teleport_agent()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done
}

function command_ita() { command_install_teleport_agent "$@"; }
function command_install_teleport_agent()
{
    if $INSIDE_CONTAINER; then
        warn This command must run from outside this container
        exit 1
    fi

    read_config customer_name "Customer name"
    read_config USERNAME "Username"
    read_config HOSTNAME "Hostname"
    read_config region "Region"

    cat > .teleport-config.tmp <<-EOF
		teleport:
		  nodename: ${customer_name}-${HOSTNAME}
		ssh_service:
		  enabled: yes
		  labels:
		    region: ${region}
		    user: ${USER}
		    team: "operations"
		EOF

    info 'Go to https://getup.teleport.sh/web/cluster/getup.teleport.sh/nodes and paste the command from "ADD SERVER" below'
    read_config teleport_install_command 'Paste the command here'
    eval "$teleport_install_command"

    info Updating config...
    yq eval-all 'select(fileIndex == 0) * select(fileIndex == 1)' /etc/teleport.yaml .teleport-config.tmp > teleport.yaml
    sudo cp -fv teleport.yaml /etc/teleport.yaml
    rm -f .teleport-config.tmp teleport.yaml
    info Restarting teleport-agent...
    sudo systemctl restart teleport
    info done
}


####################
## COMMAND: start ##
####################

standalone=false
docker_command="" # /bin/bash
port_range=32000-32010
run_as_root=false
default_docker_image_repo='ghcr.io/getupcloud/managed-cluster'
docker_image=''
env_file=""
force_docker_image_build=false
sudo=sudo

function getopt_s() { _command=start && getopt_start "$@"; }
function getopt_start()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -s|--standalone)
                standalone=true
            ;;
            -P|--port-range)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                port_range=$1
            ;;
            -r|--run-as-root)
                run_as_root=true
            ;;
            --no-sudo)
                sudo=""
            ;;
            -e|--env-file)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                env_file=$1
            ;;
            -i|--image)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                docker_image=$1
            ;;
            --force-docker-image-build)
                force_docker_image_build=true
            ;;
            --)
                shift
                docker_command="${@@Q}"
                shift $#
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    docker_image=$(get_docker_image)

    select_cluster $cluster_dir
}

function check_dependencies()
{
    local status=0

    for bin in jq make; do
        if ! which $bin &>/dev/null; then
            warn "Missing required command: $bin"
            status=1
        fi
    done

    for lib in giturlparse; do
        if ! python3 -c "import $lib; print($lib)" &>/dev/null && ! python -c "import $lib; print($lib)" &>/dev/null; then
            warn "Missing required python lib: $lib"
            status=1
        fi
    done

    return $status
}

function check_deprecations()
{
    local removed_files=(
        $CLUSTER_DIR/providers-common.tf
    )

    for i in ${removed_files[*]}; do
        if [ -e "$i" ]; then
            if ask "Remove deprecated file '$i'? [Y/n]"; then
                rm -vf "$i"
            fi
        fi
    done

    local old_cluster_configs=(
        upstream_git_repo
        origin_git_repo
        https_origin_git_repo
        flux_git_repo
    )

    for i in ${old_cluster_configs[*]}; do
        if grep -q $i $CLUSTER_CONF; then
            warn "DEPRECATED: $CLUSTER_CONF: $i: Please remove this config."
        fi
    done

    local rename_configs=(
        type:cluster_type
        name:cluster_name
        customer:customer_name
        sla:cluster_sla
        :cluster_provider
        aws_modules:modules
    )

    local TERRAFORM_TFVARS=$CLUSTER_DIR/terraform.tfvars

    for i in ${rename_configs[*]}; do
        local old=${i%:*}
        local new=${i#*:}
        local found=false

        if [ -z "${!new}" ] && [ -z "$old" ]; then
            case "$new" in
                cluster_provider)
                    select_cluster_provider
                    set_config $new="$cluster_provider" "Cluster Provider" $CLUSTER_CONF
                    continue
                ;;
            esac
        fi

        {
            if grep -q "^\s*$old\s*=" $REPO_CONF; then
                found=true
                file=$REPO_CONF
            elif grep -q "^\s*$old\s*=" $CLUSTER_CONF; then
                found=true
                file=$CLUSTER_CONF
            elif grep -q "^\s*$old\s*=" $TERRAFORM_TFVARS; then
                found=true
                file=$TERRAFORM_TFVARS
            fi
        } 2>/dev/null

        if $found; then
            if ask "Replace deprecated config '$old' for '$new' into file $file? [Y/n]"; then
                sed -i -e "s/^\s*$old\(\s*=\)/$new\1/g" $file
            fi
        fi
    done
}

function command_s() { command_start "$@"; }
function command_start()
{
    if ! check_dependencies; then
        info "Execute 'make install' or install missing command(s) or lib(s)"
        exit 1
    fi

    check_update

    if $standalone; then
        export CLUSTER_DIR="$ROOT_DIR/standalone"
        mkdir -p $CLUSTER_DIR
        touch $CLUSTER_DIR/terraform.tfvars
        touch $REPO_CONF
        export CLUSTER_CONF=$CLUSTER_DIR/cluster.conf
        touch $CLUSTER_CONF
    fi

    update_globals
    start_container
}

############################
## COMMAND: sync-template ##
############################

function getopt_st() { _command=sync_template && getopt_sync_template "$@"; }
function getopt_sync_template()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    select_cluster $cluster_dir
}

function command_st() { command_sync_template "$@"; }
function command_sync_template()
{
    check_update
    assert_cluster_dir
    check_deprecations
    sync_from_template
    merge_requires
}

###########################
## COMMAND: remote-setup ##
###########################

function getopt_rs() { _command=remote_setup && getopt_remote_setup "$@"; }
function getopt_remote_setup()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            --force)
                force=true
            ;;
            -o|--origin)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_origin=$1
            ;;
            -u|--upstream)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_upstream=$1
            ;;
            -f|--flux-git-repo)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                opt_flux_git_repo=$1
        esac
        shift
    done
}

function command_rs() { command_remote_setup "$@"; }
function command_remote_setup()
{
    set -e
    line
    info Current remotes:
    git remote -v

    source_env $REPO_CONF

    if [ -z "$opt_upstream$opt_origin$opt_flux_git_repo" ]; then
        read_config upstream "Set UPSTREAM remote"
        read_config origin "Set ORIGIN remote"
        read_config flux_git_repo "Flux git repository"
    else
        [ -z "$opt_upstream" ] || read_config upstream "Set UPSTREAM remote"
        [ -z "$opt_origin" ] || read_config origin "Set ORIGIN remote"
        [ -z "$opt_flux_git_repo" ] || read_config flux_git_repo "Flux git repository"
    fi

    line
    info Will update to:
    info "-> upstream: $upstream"
    info "-> origin: $origin"
    info "-> flux_git_repo: $flux_git_repo"

    if ! $force; then
        if ! ask "Continue? [Y/n]"; then
            return
        fi
    fi

    save_repo_config
    update_git_remotes

    line
    info New remotes:
    git remote -v
}

#####################
## COMMAND: update ##
#####################

update_version=""

function getopt_u() { _command=update && getopt_update "$@"; }
function getopt_update()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -f|--force)
                force=true
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done
}

function command_u() { command_update "$@"; }
function command_update()
{
    check_update
}

###########################
## COMMAND: repo-pull    ##
###########################

function getopt_rp() { _command=repo_pull && getopt_repo_pull "$@"; }
function getopt_repo_pull()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            *)
                invalid_argument $1
        esac
        shift
    done
}

function command_rp() { command_repo_pull "$@"; }
function command_repo_pull()
{
    cd $REPO_DIR
    for remote in origin upstream; do
        if ! git remote get-url $remote &>/dev/null; then
            info "Missing remote: $remote"
            ask_execute_command $0 remote-setup
            break
        fi
    done

    repo_pull_remote origin
    repo_fetch_remote upstream
}

function repo_pull_remote()
{
    local remote=$1
    local remote_url=$(git remote get-url $remote 2>/dev/null || echo '<none>')
    info "--> pull remote:" $remote: $remote_url
    ask_execute_command git pull $remote main --tags
}

function repo_fetch_remote()
{
    local _force=${_force:-false}
    local remote=$1
    local remote_url=$(git remote get-url $remote 2>/dev/null || echo '<none>')
    info "--> fetch remote:" $remote: $remote_url
    if $_force; then
        git fetch $remote --tags
    else
        ask_execute_command git fetch $remote --tags
    fi
}

function check_update()
{
    if $no_check_update || ! [ -e "$REPO_CONF" ]; then
        return 0
    fi

    cd $REPO_DIR
    info "Checking for updates (current version $current_version) ..."

    if [ "$(git_remote upstream)" != "$default_upstream" ] && [ "$(git_remote upstream)" != "$default_upstream_https" ]; then
        info "Remote upstream doesn't matches $default_upstream"
        info "Execute \`$0 remote-setup\` and try again."
        return
    fi

    if [ -z "$version" ]; then
        set_config version="$current_version" "Installer version" $REPO_CONF
    fi

    local has_updates=false
    local latest_local_version=$(get_latest_version)

    # check if upstream has a newer version than our local latest version and asks to download it.
    # TODO: parse upstream url from git remote
    local latest_remote_version=''
    if ! latest_remote_version=$(timeout -v 10 curl -s -H 'cache-control: no-cache' \
          'https://api.github.com/repos/getupcloud/managed-cluster/tags?sort=created&order=asc' \
          | jq '.[0].name' -r | cut -c 2-); then
        echo Unable to retrieve latest version from upstream
        return 1
    fi

    if $force; then
        warn "Forcing update"
    fi

    if $force || [ "$(fmt_version $latest_remote_version)" -gt "$(fmt_version $latest_local_version)" ]; then
        has_updates=true
        if $force || _default=n ask "Remote repo has newer version (latest local: v$latest_local_version, latest remote: v$latest_remote_version). Download now? [y/N]"; then
            _force=$force repo_fetch_remote upstream
            latest_local_version=$(get_latest_version)
        fi
    fi

    if $force || [ "$(fmt_version $latest_local_version)" -gt "$(fmt_version $version)" ]; then
        has_updates=true
        if $force || _default=n ask "Upgrade to newer version ${latest_local_version}? [y/N]"; then
            if $force; then
                git merge v${latest_local_version} -Xtheirs -m "Merge tag v${latest_local_version} (forced)"
            else
                ask_execute_command git merge v${latest_local_version} -Xtheirs
            fi
            current_version=$(get_current_version)
            set_config version="$latest_local_version" "Installer version" $REPO_CONF
            exit 0
        fi
    fi
}

#############################
## COMMAND: update-ssh-key ##
#############################

function getopt_usk() { _command=update_ssh_key && getopt_update_ssh_key "$@"; }
function getopt_update_ssh_key()
{
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                usage
            ;;
            -k|--ssh-key-type)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_type=$1
            ;;
            -l|--ssh-key-length)
                [ $# -lt 2 ] && invalid_argument $1
                shift
                ssh_key_length=$1
            ;;
            --force)
                force=true
            ;;
            --local-git-repo)
                opt_local_git_repo=true
            ;;
            *)
                if [ -z "$cluster_dir" ]; then
                    cluster_dir=$1
                else
                    invalid_argument $1
                fi
        esac
        shift
    done

    if $opt_local_git_repo; then
        set_local_git_repo
    fi

    if [ $ssh_key_length -eq 0 ]; then
        local key_len=ssh_key_length_$ssh_key_type
        ssh_key_length=${!key_len}
    fi

    select_cluster $cluster_dir
}

function command_usk() { command_update_ssh_key "$@"; }
function command_update_ssh_key()
{
    if ! $force; then
        if ! ask "Generate new ssh keys now for $CLUSTER_DIR? [Y/n]"; then
            return
        fi
    fi

    if [ -e $CLUSTER_DIR/identity ]; then
        local bkp=$CLUSTER_DIR/identity.bkp$(date +%s)
        info Renaming existing ssh key $CLUSTER_DIR/identity to $bkp
        mv $CLUSTER_DIR/identity $bkp
    fi

    generate_ssh_key
    #generate_ssh_key repo
}

##########
## Main ##
##########

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            usage
        ;;
        -d|--debug)
            debug=true
            verbose=true
        ;;
        -v|--verbose)
            verbose=true
        ;;
        -U|--no-check-update)
            no_check_update=true
        ;;
        --)
            break
        ;;
        -*)
            invalid_argument $1
        ;;
        *)
            if [ -z "$command" ]; then
                command=$1
                shift
                break
            else
                exit_code=1
                usage
            fi
    esac
    shift
done

_command=${command//-/_}

if [ -z "$_command" ] || [ "$(type -t command_$_command)" != function ]; then
    usage
    exit 1
fi

if [ "$(type -t getopt_$_command)" == function ]; then
    eval getopt_$_command "$@"
fi

$debug && set -x
$verbose && dump_options

eval command_$_command
